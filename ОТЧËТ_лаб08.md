# Отчет по лабораторной работе №08

# Резервное копирование и управление доступом

## Сведения о студенте

**Дата:** 2025-12-01
**Семестр:** 7
**Группа:** ПИЖ-б-о-22-1
**Дисциплина:** Администрирование баз данных
**Студент:** Матвеев Александр Иванович

## Цель работы
  - Освоить методы резервного копирования и восстановления данных в PostgreSQL.
  - Изучить различия между логическим и физическим резервным копированием.
  - Получить практические навыки настройки PITR (восстановление на момент времени) и управления правами доступа.

-----

## Теоретическая часть

### Основные понятия

  * **Логическое резервное копирование** — создание архивных копий с помощью утилит `pg_dump` и `pg_dumpall`. Представляет собой набор SQL-команд для воссоздания структуры и данных. Метод гибок, но может быть медленным для больших БД.
  * **Физическое резервное копирование** — побитовое копирование файлов данных кластера (обычно через `pg_basebackup`). Это быстрее, но требует идентичной версии СУБД для восстановления.
  * **WAL-архивация и PITR** — механизм непрерывного сохранения сегментов журналов предзаписи (Write-Ahead Log). Позволяет восстановить состояние базы данных на любую секунду в прошлом (Point-in-Time Recovery). 
  * **Обновление сервера** — перенос данных на новую мажорную версию PostgreSQL (например, с 15 на 16), часто выполняемый через логический дамп. 

-----

## Практическая часть

### Модуль 1: Управление доступом

#### Задача 1. Настройка привилегий и аутентификации

**Цель:** Закрепить навыки управления ролями и настройки файла `pg_hba.conf`.

**Выполнение:**

1.  **Создание базы данных и ролей:**

Создание новой бд для выполнения лабораторной работы
```bash
sudo -u postgres createdb lab07_db
```

```sql
-- Создание групповых ролей
CREATE ROLE writer;
CREATE ROLE reader;
```

2.  **Настройка привилегий на схему public:**
По умолчанию в PostgreSQL 16 роль `PUBLIC` (все пользователи) имеет право создавать объекты в схеме `public`. Отзываем это право. Выдаём права роли `writer` и `reader`.

```sql
REVOKE CREATE ON SCHEMA public FROM PUBLIC;

GRANT CREATE, USAGE ON SCHEMA public TO writer;

GRANT USAGE ON SCHEMA public TO reader;
```

3.  **Настройка привилегий по умолчанию (ALTER DEFAULT PRIVILEGES):**
Чтобы пользователь `reader` мог читать таблицы, которые создаст `writer`, необходимо изменить права по умолчанию.

```sql
ALTER DEFAULT PRIVILEGES FOR ROLE writer 
GRANT SELECT ON TABLES TO reader;
```

4.  **Создание пользователей и проверка:**

Создание пользователей
```sql
CREATE USER w1 WITH PASSWORD 'pass' IN ROLE writer;
CREATE USER r1 WITH PASSWORD 'pass' IN ROLE reader;
```

5.  **Тестирование доступа:**
Подключение под w1:
```bash
psql -d lab07_db -U w1 -h localhost
```

```sql
CREATE TABLE test_table (id int);
INSERT INTO test_table VALUES (1);
```

Подключение под r1:
```bash
psql -d lab07_db -U r1 -h localhost
```

```sql
SELECT * FROM test_table;
```
Вывод:
```text
 id 
----
  1
(1 row)
```

```sql
DELETE FROM test_table;
```
Вывод: 
`ERROR:  permission denied for table test_table`

**Вывод:** Настроена схема, где создатель данных автоматически делится правами на чтение с группой читателей, но защищен от изменения данных третьими лицами.

#### Задача 2. Аутентификация (pg\_hba.conf)

**Цель:** Настроить методы аутентификации и маппинг пользователей ОС.

**Выполнение:**

1.  **Создание ролей Alice и Bob:**

```sql
CREATE USER alice;
CREATE USER bob;
```


2.  **Редактирование pg\_hba.conf:**
Открытие файла конфигурации:
`sudo nano /etc/postgresql/16/main/pg_hba.conf`

Изменяем записи, чтобы запретить вход всем, кроме `postgres` и `student` (через trust).
```text
# TYPE  DATABASE        USER            ADDRESS                 METHOD
# local   replication     all                                     trust
local   all             postgres                                peer
local   all             student                                 peer
local   all             alice,bob                               peer map=conf_map
local   all             all                                     reject

```

Перезагрузка конфигурации:

```bash
sudo systemctl reload postgresql
```

Проверка входа под alice:

```bash
psql -d access_db -U alice
```
Вывод:
```text
psql: error: connection to server on socket "/var/run/postgresql/.s.PGSQL.5432" failed: FATAL:  database "access_db" does not exist
```

*Результат:* Вход запрещен.

3.  **Настройка PEER аутентификации и карты имен (pg\_ident.conf):**
Задача: разрешить вход пользователю ОС `alice` под ролью БД `alice`.

* Создание пользователя в ОС:

```bash
sudo adduser alice
```

* Редактирование `pg_ident.conf` (сопоставление):

Открытие файла идентификации:
```bash
sudo nano /etc/postgresql/16/main/pg_ident.conf
```

Добавление строки:
```text
my_map          alice                   alice
```

Перезагрузка: `sudo systemctl reload postgresql`

4.  **Проверка входа:**
```bash
sudo -u alice psql -d lab07_db
```
Результат: Успешный вход без пароля, так как пользователь ОС `alice` соответствует пользователю БД через карту `my_map`.

5.  **Один маппинг для нескольких ролей:**

В `pg_ident.conf` добавляем строку:
```text
my_map          alice                   bob
```

Теперь пользователь ОС `alice` сможет входить и как `bob` (если в `pg_hba.conf` разрешить это для `bob`). Это подтверждает гибкость `pg_ident.conf`.

-----

### Модуль 2: Логическое резервное копирование

#### Задача 1. Простой дамп и восстановление

**Цель:** Создать логическую копию БД и восстановить её.

**Выполнение:**

1.  Подготовка данных:

Создание новой бд для выполнения лабораторной работы
```bash
sudo -u postgres createdb backup_db
psql -d backup_db
```

```sql
CREATE TABLE important_data (id serial primary key, info text);
INSERT INTO important_data (info) VALUES ('String 1'), ('String 2');
```

2.  Создание дампа при помощи утилиты `pg_dump`.

```bash
pg_dump -d backup_db -f backup_db_full.sql
```

3.  Удаление и восстановление:


```bash
# Удаляем БД (имитация аварии)
sudo -u postgres dropdb backup_db

# Создаем чистую БД
sudo -u postgres createdb backup_db

# Восстанавливаем из файла
psql -d backup_db -f backup_db_full.sql
```

**Результат:**

```text
 set_config 
------------
 
(1 row)

SET
SET
SET
SET
SET
SET
CREATE TABLE
ALTER TABLE
CREATE SEQUENCE
ALTER SEQUENCE
ALTER SEQUENCE
ALTER TABLE
COPY 2
 setval 
--------
      2
(1 row)
```

Данные успешно восстановлены, таблица `important_data` содержит 2 строки.
```text
backup_db=# SELECT * FROM important_data;
 id |   info   
----+----------
  1 | String 1
  2 | String 2
(2 rows)
```

#### Задача 2. Параллельный дамп

**Цель:** Использовать параллельный режим и дамп глобальных объектов.

**Выполнение:**

1.  Создание нескольких БД с объектами: 

Создадим две дополнительные базы данных для тестирования массового копирования.
```sql
CREATE DATABASE db_part1;
CREATE DATABASE db_part2;
\c db_part1
CREATE TABLE t1 AS SELECT generate_series(1, 100000) AS id;
\c db_part2
CREATE TABLE t2 AS SELECT generate_series(1, 50000) AS id;
\q
```

2.  Копия глобальных объектов:  

Сохраняем пользователей, группы и права доступа (то, что не входит в дамп отдельной БД).

```bash
pg_dumpall --globals-only -f globals_dump.sql
```

3. Параллельный дамп баз данных: 

```bash
# Дамп первой БД
pg_dump -j 2 -Fd -d db_part1 -f dump_db1_dir

# Дамп второй БД
pg_dump -j 2 -Fd -d db_part2 -f dump_db2_dir
```

*Вывод:* Параллельный дамп ускоряет процесс для больших баз данных, создавая структуру каталогов вместо одного файла.

#### Задача 3. Восстановление кластера

**Цель:** Восстановить весь кластер из созданных копий (имитация переезда на чистый сервер)

**Выполнение:**

1. Имитация чистого сервера: Удаляем созданные базы данных.

```bash
sudo -u postgres dropdb db_part1
sudo -u postgres dropdb db_part2
```

2. Восстановление глобальных объектов:

```bash
sudo -u postgres psql < globals_dump.sql
```

**Результат:**

```text
ERROR:  role "alice" already exists
ALTER ROLE
ERROR:  role "bob" already exists
ALTER ROLE
ERROR:  role "ext_user" already exists
ALTER ROLE
ERROR:  role "postgres" already exists
ALTER ROLE
ERROR:  role "r1" already exists
ALTER ROLE
ERROR:  role "reader" already exists
ALTER ROLE
ERROR:  role "student" already exists
ALTER ROLE
ERROR:  role "w1" already exists
ALTER ROLE
ERROR:  role "writer" already exists
ALTER ROLE
NOTICE:  role "r1" has already been granted membership in role "reader" by role "postgres"
GRANT ROLE
NOTICE:  role "w1" has already been granted membership in role "writer" by role "postgres"
GRANT ROLE
```
Ошибки "role already exists" допустимы, если мы не удаляли роли. Если сервер был бы чистым, роли бы создались.

-----

#### Задача 4. Проблемы при загрузке.

**Цель:** Смоделировать ошибку при загрузке данных из-за несовпадения форматов.

**Выполнение:**

1. Создание проблемных данных:

Создаем файл, где разделителем является точка с запятой ;
```bash
echo "1;Test Data" > /tmp/bad_format.csv
```

2. Попытка загрузки:

Создаем таблицу и пытаемся загрузить данные, ожидая запятую.
```sql
CREATE TABLE load_test (id int, val text);
COPY load_test FROM '/tmp/bad_format.csv' DELIMITER ',';
```

**Результат:**
```text
ERROR:  invalid input syntax for type integer: "1;Test Data"
CONTEXT:  COPY load_test, line 1, column id: "1;Test Data"
```
PostgreSQL не смог разделить строку на колонки, так как не нашел указанного разделителя `,`. Для исправления нужно указать `DELIMITER ';'`.

-----

## Итоговые выводы

В ходе лабораторной работы были освоены:

1.  **pg\_dump/pg\_restore:** Эффективны для переноса отдельных БД и миграции между версиями. Параллельный режим (`-j`) существенно ускоряет процесс, но требует directory-формата.
2.  **pg\_basebackup:** Позволяет быстро развернуть точную копию всего экземпляра. Работа с `tablespace_map` необходима, если пути на новом сервере отличаются.
3.  **PITR (Point-in-Time Recovery):** Наиболее мощный инструмент защиты данных. Комбинация базового бэкапа и архива WAL позволяет восстановить данные с точностью до транзакции, отменив последствия случайных удалений (`DROP`/`TRUNCATE`), что было доказано на практике в Модуле 3.