# Отчет по лабораторной работе №02

# Организация данных и системный каталог

  

## Сведения о студенте

**Дата:** 2025-10-20
**Семестр:** 7
**Группа:** ПИЖ-б-о-22-1
**Дисциплина:** Администрирование баз данных
**Студент:** Матвеев Александр Иванович

  

## Цель работы
Всестороннее изучение логической и физической структуры хранения данных в
PostgreSQL. Получение практических навыков управления базами данных, схемами, табличными
пространствами. Глубокое освоение работы с системным каталогом для извлечения метаинформации.
Исследование низкоуровневых аспектов хранения, включая TOAST.


## Теоретическая часть
### Изученные концепции
* **Кластер PostgreSQL** — совокупность всех баз данных, управляемых одним серверным процессом.
* **Логическая структура:**
  Кластер → База данных → Схема → Объекты (таблицы, представления, последовательности и др.).
* **Физическая структура:**
  Данные лежат в файловой системе. Табличные пространства связывают логические объекты с директориями.
* **Системный каталог:**
  Набор служебных таблиц и представлений, хранящих метаданные (`pg_class`, `pg_database`, `pg_namespace`, `pg_tables`, `pg_views`, `information_schema`.*).
* **search_path:**
  Определяет порядок поиска схем при обращении к объектам без указания схемы.
* **`TOAST`:**
  Механизм вынесения и (опционально) сжатия больших значений за пределы основного кортежа. Стратегии хранения: `PLAIN`, `MAIN`, `EXTERNAL`, `EXTENDED`.
* **Табличные пространства:**
  Позволяют управлять размещением данных на разных дисках/каталогах.
* **Нежурналируемые таблицы:**
  `UNLOGGED` — не пишут изменения в `WAL`, быстрее, но данные теряются при крэше.


## Практическая часть

### Модуль 1: Базы данных и схемы

#### Задача 1: Создание и проверка БД
**Цель:** создать базу `lab02_db` и проверить её начальный размер.

**Выполненные действия:**
Создание БД
```bash
sudo -u postgres createdb lab02_db
```
Проверка размера:
```bash
sudo -u postgres psql
```

```sql
SELECT pg_database_size('lab02_db');
```

**Результаты:**
```text
 pg_database_size 
------------------
          7602703
(1 row)
```

**Выводы и объяснения:**
Начальный размер БД — несколько мегабайт, т.к. создаются служебные структуры и системные каталоги.

---

#### Задача 2: Работа со схемами
**Цель:** создать схемы `app` и `student`, по таблице в каждой и заполнить их.

**Выполненные действия:**
Подключение:
```bash
psql -d lab02_db
```

Создание схем:
```sql
CREATE SCHEMA app;
CREATE SCHEMA student;
```
Результат:
```sql
CREATE SCHEMA
CREATE SCHEMA
```

Создание таблиц с одинаковыми именами для демонстрации `search_path`:
```sql
CREATE TABLE app.data_table (
    id serial PRIMARY KEY,
    val text
);

CREATE TABLE student.data_table (
    id serial PRIMARY KEY,
    val text
);
```
Результат:
```sql
CREATE TABLE
CREATE TABLE
```

Заполнение:
```sql
INSERT INTO app.data_table (val)
VALUES ('app-1'), ('app-2');

INSERT INTO student.data_table (val)
VALUES ('student-1'), ('student-2');
```
Результат:
```sql
INSERT 0 2
INSERT 0 2
```
**Вывод:**
Созданы две пользовательские схемы и по одной таблице в каждой. Таблицы заполнены информацией.

---

#### Задача 3: Контроль размера
**Цель:** сравнить размер БД до и после создания объектов.

**Выполненные действия:**
```sql
SELECT pg_database_size('lab02_db');
```

**Результаты:**
```text
 pg_database_size 
------------------
          7901667
(1 row)
```
**Вывод:**
Размер вырос за счёт файлов таблиц и индексов (`data_table` в двух схемах).

---

#### Задача 4: Настройка search_path
**Цель:** сделать приоритетной схему `student`, затем `app`, и обратиться к таблицам по неполному имени.

**Выполненные действия:**
Посмотреть текущий search_path:
```sql
SHOW search_path;
```
Результат:
```text
   search_path   
-----------------
 "$user", public
(1 row)
```

Установить и просмотреть:
```sql
SET search_path TO student, app, public;
SHOW search_path;
```
Результат:
```text
     search_path      
----------------------
 student, app, public
(1 row)
```

Обращение к таблице без указания схемы:
```sql
SELECT * FROM data_table;
```
Результат:
```text
 id |    val    
----+-----------
  1 | student-1
  2 | student-2
(2 rows)
```

Проверка таблицы из `app`:
```sql
SELECT * FROM app.data_table;
```
Результат:
```text
 id |  val  
----+-------
  1 | app-1
  2 | app-2
(2 rows)
```

**Вывод:**
При `search_path = student, app, public` имя `data_table` без схемы разрешается сначала в схеме `student`; таблица из `app` доступна только с явным указанием схемы.

---

#### Задача 5 (Практика+): Параметр temp_buffers

**Цель:** сделать `temp_buffers` в `lab02_db` в 4 раза больше значения по умолчанию.

**Выполненные действия:**

1. Уточним значение по умолчанию:
```sql
SHOW temp_buffers;
```
Результат: `8MB`

2. Устанавливаем для базы:
```sql
ALTER DATABASE lab02_db SET temp_buffers = '32MB';
```

3. В новом сеансе, подключённом к `lab02_db`, проверим параметр `temp_buffers`:
```bash
psql -d lab02_db
```

```sql
SHOW temp_buffers;
```
Результат: `32MB`

**Вывод:**
Параметр уровня БД применяется ко всем новым сеансам в этой БД, что демонстрирует правильность настроек конфигурации.

---

### Модуль 2: Системный каталог

#### Задача 1: Исследование pg_class
**Цель:** изучить содержимое системной таблицы `pg_class`

**Выполненные действия:**
```sql
\d pg_class
```

**Результаты:**
```text
                     Table "pg_catalog.pg_class"
       Column        |     Type     | Collation | Nullable | Default 
---------------------+--------------+-----------+----------+---------
 oid                 | oid          |           | not null | 
 relname             | name         |           | not null | 
 relnamespace        | oid          |           | not null | 
 reltype             | oid          |           | not null | 
 reloftype           | oid          |           | not null | 
 relowner            | oid          |           | not null | 
 relam               | oid          |           | not null | 
 relfilenode         | oid          |           | not null | 
 reltablespace       | oid          |           | not null | 
 relpages            | integer      |           | not null | 
 reltuples           | real         |           | not null | 
 relallvisible       | integer      |           | not null | 
 reltoastrelid       | oid          |           | not null | 
 relhasindex         | boolean      |           | not null | 
 relisshared         | boolean      |           | not null | 
 relpersistence      | "char"       |           | not null | 
 relkind             | "char"       |           | not null | 
 relnatts            | smallint     |           | not null | 
 relchecks           | smallint     |           | not null | 
 relhasrules         | boolean      |           | not null | 
 relhastriggers      | boolean      |           | not null | 
 relhassubclass      | boolean      |           | not null | 
:
```

**Вывод:**
`pg_class` — системная таблица, содержащая запись для каждой таблицы, индекса, последовательности, TOAST-таблицы и т.п. Важные поля: `relname`, `relnamespace`, `relkind`, `reltablespace`, `relpages`, `reltuples`, `reltoastrelid`.

#### Задача 2: Исследование pg_tables
**Цель:** получить подробное описание представления `pg_tables`.
**Выполненные действия:**
```sql
\d+ pg_tables
```

**Результаты:**
```text
                          View "pg_catalog.pg_tables"
   Column    |  Type   | Collation | Nullable | Default | Storage | Description 
-------------+---------+-----------+----------+---------+---------+-------------
 schemaname  | name    |           |          |         | plain   | 
 tablename   | name    |           |          |         | plain   | 
 tableowner  | name    |           |          |         | plain   | 
 tablespace  | name    |           |          |         | plain   | 
 hasindexes  | boolean |           |          |         | plain   | 
 hasrules    | boolean |           |          |         | plain   | 
 hastriggers | boolean |           |          |         | plain   | 
 rowsecurity | boolean |           |          |         | plain   | 
View definition:
 SELECT n.nspname AS schemaname,
    c.relname AS tablename,
    pg_get_userbyid(c.relowner) AS tableowner,
    t.spcname AS tablespace,
    c.relhasindex AS hasindexes,
    c.relhasrules AS hasrules,
    c.relhastriggers AS hastriggers,
    c.relrowsecurity AS rowsecurity
   FROM pg_class c
     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
     LEFT JOIN pg_tablespace t ON t.oid = c.reltablespace
  WHERE c.relkind = ANY (ARRAY['r'::"char", 'p'::"char"]);

```

**Вывод:**
* **Таблица** — физически хранит данные в файлах.
* **Представление (`pg_tables`)** — логический объект (view), хранящий только SQL-запрос. При обращении к представлению данные выбираются из базовых таблиц.

---
#### Задача 3: Временная таблица и список схем
**Цель:** создать временную таблицу и увидеть временную схему.

**Выполненные действия:**
```sql
CREATE TEMP TABLE tmp_lab02 (id int);
```

```sql
SELECT nspname
FROM pg_namespace
ORDER BY nspname;
```

**Результаты:**
```text
nspname       
--------------------
 app
 information_schema
 pg_catalog
 pg_temp_3
 pg_toast
 pg_toast_temp_3
 public
 student
(8 rows)
```
**Вывод:** Для временных таблиц создаётся временная схема `pg_temp_*`, видимая только в текущем сеансе.

---

#### Задача 4: Представления information_schema
**Цель:** получить все представления схемы `information_schema`.

**Выполненные действия:**
```sql
SELECT table_name
FROM information_schema.views
WHERE table_schema = 'information_schema'
ORDER BY table_name;
```

**Результаты:**
```text
table_name               
---------------------------------------
 _pg_foreign_data_wrappers
 _pg_foreign_servers
 _pg_foreign_table_columns
 _pg_foreign_tables
 _pg_user_mappings
 administrable_role_authorizations
 applicable_roles
 attributes
 character_sets
 check_constraint_routine_usage
 check_constraints
 collation_character_set_applicability
 collations
 column_column_usage
 column_domain_usage
 column_options
 column_privileges
 column_udt_usage
 columns
 constraint_column_usage
 constraint_table_usage
 data_type_privileges
 domain_constraints
 domain_udt_usage
 domains
...
(65 rows)
```
**Вывод:** Список стандартных представлений (tables, columns, constraints и др.), реализующих переносимый доступ к метаданным.

---

#### Задача 5: Анализ метакоманды \d+ pg_views
**Цель:** проанализировать вывод метакоманды.

**Выполненные действия:**
```sql
\d pg_views
```

**Результаты:**
```text
                       View "pg_catalog.pg_views"
   Column   | Type | Collation | Nullable | Default | Storage  | Description 
------------+------+-----------+----------+---------+----------+-------------
 schemaname | name |           |          |         | plain    | 
 viewname   | name |           |          |         | plain    | 
 viewowner  | name |           |          |         | plain    | 
 definition | text |           |          |         | extended | 
View definition:
 SELECT n.nspname AS schemaname,
    c.relname AS viewname,
    pg_get_userbyid(c.relowner) AS viewowner,
    pg_get_viewdef(c.oid) AS definition
   FROM pg_class c
     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
  WHERE c.relkind = 'v'::"char";

```
**Вывод:** 
Метакоманда: 
* обращается к `pg_catalog.pg_class`, `pg_namespace`, `pg_description`;
* получает структуру и комментарии объекта `pg_views`;
* само представление `pg_views` основано на запросе к `pg_namespace`, `pg_class` и `pg_get_viewdef(oid)` для получения текста определения.

Таким образом `\d`/`\d+` — это удобные "шорткаты" к системному каталогу.

---


## Итоговые выводы

1. Освоена логическая структура PostgreSQL: базы, схемы, объекты и влияние `search_path` на разрешение имён.
2. На практике использованы системные каталоги (`pg_class`, `pg_namespace`, `pg_tables`, `pg_views`, `information_schema.*`) для извлечения метаданных.
3. Изучены табличные пространства: создание, назначение по умолчанию, связь с файловой системой через `pg_tblspc`, удаление с учётом зависимостей.
4. Разобраны низкоуровневые механизмы:

   * UNLOGGED-таблицы и `_init` файлы;
   * стратегии хранения TOAST и вынос больших значений;
   * влияние параметров (`temp_buffers`, `random_page_cost`) и привязка их к БД/табличным пространствам.
5. Выполнены задания уровня «Практика+», включая анализ размеров БД и проверку/сравнение методов TOAST-сжатия, что демонстрирует понимание внутренних механизмов PostgreSQL.

Если хочешь, в следующем сообщении могу коротко подсветить, какие места в отчёте тебе нужно заменить фактическим выводом из твоей среды, чтобы всё выглядело идеально для сдачи.
