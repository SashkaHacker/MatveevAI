# Отчет по лабораторной работе №09

# Репликация и отказоустойчивость

## Сведения о студенте

**Дата:** 2025-12-05
**Семестр:** 7
**Группа:** ПИЖ-б-о-22-1
**Дисциплина:** Администрирование баз данных
**Студент:** Матвеев Александр Иванович

## Цель работы

* Освоить настройку и управление физической и логической репликацией в PostgreSQL.
* Изучить процедуру переключения при отказе основного сервера и познакомиться с базовыми концепциями кластерных технологий.

-----

## Теоретическая часть

### Основные понятия

* **Физическая репликация** — это точное бинарное копирование данных (всего кластера) с основного сервера (мастера) на ведомый (реплику). Она обеспечивает высокую доступность и отказоустойчивость.
* **Логическая репликация** — метод репликации на уровне отдельных объектов (таблиц), позволяющий выборочно копировать данные и работать между разными версиями PostgreSQL или разными ОС.
* **Failover (Переключение)** — процедура аварийного перевода реплики в статус основного сервера при сбое мастера.
* **Слоты репликации** — механизм на мастере, гарантирующий, что необходимые для реплик WAL-файлы не будут удалены до их передачи.

-----

## Практическая часть

### Модуль 1: Физическая репликация

#### Задача 1. Базовая настройка синхронной репликации

**Цель:** Настроить потоковую репликацию между двумя экземплярами и проверить синхронный режим.

**Выполнение:**

1.  **Подготовка кластеров:**
Создаем два кластера: `main` (мастер, порт 5432) и `replica` (будущая реплика, порт 5433).

```bash
sudo pg_dropcluster 16 main --stop
sudo pg_createcluster 16 main --start
sudo pg_createcluster 16 replica
sudo systemctl stop postgresql@16-replica
```

2.  **Настройка Мастера (main):**
Создаем пользователя для репликации и настраиваем доступ.

```bash
sudo -u postgres psql -p 5432 -c "CREATE USER replicator WITH REPLICATION ENCRYPTED PASSWORD 'pass';"
```

Изменение `pg_hba.conf`:

```bash
sudo nano /etc/postgresql/16/main/pg_hba.conf
```
Добавляем строку:
```text
host    replication     replicator      127.0.0.1/32            scram-sha-256
```


Редактируем `postgresql.conf` для включения синхронной репликации:

```bash
sudo nano /etc/postgresql/16/main/postgresql.conf
```
Изменение параметров:
```text
listen_addresses = '*'
wal_level = replica
synchronous_commit = on
synchronous_standby_names = 'my_replica'
```

Перезагружаем мастер:

```bash
sudo systemctl restart postgresql@16-main
```

3.  **Создание базовой резервной копии (Basebackup):**
Очищаем директорию реплики и клонируем мастер.

```bash
sudo rm -rf /var/lib/postgresql/16/replica/*
sudo -u postgres pg_basebackup -h 127.0.0.1 -p 5432 -U replicator -D /var/lib/postgresql/16/replica -Fp -Xs -R
```

4.  **Настройка Реплики:**
В файле конфигурации реплики меняем порт и имя приложения (для синхронного режима).

```bash
sudo nano /etc/postgresql/16/replica/postgresql.conf
```

Вставляем: 
```
# port = 5433
# primary_conninfo = 'host=127.0.0.1 port=5432 user=replicator password=pass application_name=my_replica'
```


Запускаем реплику:
```bash
sudo systemctl start postgresql@16-replica
```

5.  **Проверка работы:**
Подключение: 

```bash
# К мастеру
sudo -u postgres psql -p 5432 -d postgres

# К реплике
sudo -u postgres psql -p 5433 -d postgres
```

На мастере создаем таблицу и вставляем данные:

```sql
CREATE TABLE phys_test (id int);
INSERT INTO phys_test VALUES (1);
```

На реплике проверяем появление данных:

```sql
SELECT * FROM phys_test;
```


*Результат:* 
```text
 id 
----
  1
(1 row)
```

Проверка блокировки транзакции при остановке реплики:

```bash
sudo systemctl stop postgresql@16-replica
```

На мастере:

```sql
INSERT INTO phys_test VALUES (2); -- Транзакция "висит"
```

*Вывод:* В синхронном режиме мастер ждет подтверждения от реплики. После запуска реплики транзакция завершается.

#### Задача 2. Конфликты применения

**Цель:** Изучить конфликты между запросами на чтение (на реплике) и очисткой (на мастере).

**Выполнение:**

1.  **Настройка конфликта:**
На реплике отключаем откладывание конфликтов:

```sql
-- На реплике (5433)
ALTER SYSTEM SET max_standby_streaming_delay = 0;
SELECT pg_reload_conf();
```

2.  **Моделирование ситуации:**

* **Реплика:** Запускаем долгий запрос чтения.
```sql
BEGIN;
SELECT * FROM phys_test, pg_sleep(15);
```
* **Мастер:** Удаляем данные и запускаем `VACUUM`.
```sql
DELETE FROM phys_test;
VACUUM phys_test;
```
* **Результат на реплике:**
```text
ERROR:  canceling statement due to conflict with recovery
DETAIL:  User query might have needed to see row versions that must be removed.
```
Запрос был принудительно прерван.

3.  **Включение обратной связи (Feedback):**
Включаем `hot_standby_feedback`.

На реплике:
```sql
ALTER SYSTEM SET hot_standby_feedback = on;
SELECT pg_reload_conf();
```

Повторяем эксперимент. Теперь `VACUUM` на мастере ждет, пока реплика закончит чтение. Конфликт устранен.

#### Задача 3. Слоты репликации

**Цель:** Убедиться, что слот предотвращает удаление WAL-файлов, пока они нужны реплике.

**Выполнение:**

1.  **Создание слота на мастере:**
```sql
SELECT pg_create_physical_replication_slot('test_slot');
```
2.  **Остановка реплики и генерация WAL:**
Останавливаем реплику.
```bash
sudo systemctl stop postgresql@16-replica
```

Генерация данных на мастере (чтобы вызвать ротацию WAL)
```sql
INSERT INTO test_load (info)
SELECT md5(random()::text)
FROM generate_series(1, 5000000);
```

3.  **Проверка:**
Через `pg_replication_slots` видим, что `active = f`, но слот существует. WAL-файлы не удаляются процессом `autovacuum` или чекпоинтами, так как они нужны слоту.

4.  **Удаление слота:**
```sql
SELECT pg_drop_replication_slot('test_slot');
```

Теперь старые WAL-файлы удаляются, место освобождается.

-----

### Модуль 2: Логическая репликация

#### Задача 1. Настройка публикации и подписки

**Цель:** Настроить репликацию одной таблицы между двумя базами данных.

**Выполнение:**

**Предварительная настройка:** 
```sql
ALTER SYSTEM SET wal_level = logical;
```
Перезапуск сервера: 
```bash
sudo systemctl restart postgresql
```

### 1. Создание баз данных

```sql
CREATE DATABASE db1;
CREATE DATABASE db2;
```

-----

### 2. Подготовка источника (db1)

```bash
\c db1
```

1.  **Создание таблицы и наполнение её данными:**

```sql
CREATE TABLE products (
    id serial PRIMARY KEY,
    name text,
    price numeric
);

INSERT INTO products (name, price) VALUES 
('Laptop', 1000), 
('Mouse', 20), 
('Keyboard', 50);
```

2.  **Создание публикации:**
Мы объявляем, что хотим публиковать изменения из этой таблицы.

```sql
CREATE PUBLICATION my_publication FOR TABLE products;
```

-----

### 3. Перенос структуры таблицы (pg\_dump)

```bash
sudo -u postgres pg_dump -d db1 --schema-only -t products | sudo -u postgres psql -d db2
```
-----

### 4. Настройка подписчика (db2)

```bash
\c db2
```

**Создание подписки:**
```sql
CREATE SUBSCRIPTION my_subscription
CONNECTION 'host=127.0.0.1 port=5432 user=postgres password=postgres dbname=db1'
PUBLICATION my_publication;
```

-----

### Шаг 5. Проверка

Сразу после создания подписки данные должны "перетечь" из `db1` в `db2`.

Находясь в `db2`:
```sql
SELECT * FROM products;
```

-----

### Модуль 3: Переключение (Failover)

**Цель:** Выполнить ручное переключение роли мастера на реплику при "сбое".

**Выполнение:**

1.  **Имитация сбоя:**
Останавливаем мастер (порт 5432).

```bash
sudo systemctl stop postgresql@16-main
```

2.  **Диагностика на реплике:**
Попытка записи на реплике:

```sql
INSERT INTO phys_test VALUES (100);
```

*Ошибка:* `cannot execute INSERT in a read-only transaction`. Реплика все еще в режиме "только чтение".

3.  **Продвижение реплики (Promote):**
Выполняем команду для перевода реплики в режим мастера:

```bash
sudo -u postgres /usr/lib/postgresql/16/bin/pg_ctl promote -D /var/lib/postgresql/16/replica
```

4.  **Проверка статуса:**

```sql
SELECT pg_is_in_recovery(); 
```

*Результат:* `f — сервер вышел из режима recovery и стал мастером.

```sql
INSERT INTO phys_test VALUES (100, 'New Master');
```

-----

## Итоговые выводы

1.  **Физическая репликация** проста в настройке и надежна для создания полных копий БД (HA-кластер). Синхронный режим гарантирует сохранность данных (RPO=0), но может замедлить запись на мастере при сетевых проблемах.
2.  **Конфликты восстановления** возникают, когда аналитические запросы на реплике блокируют очистку старых версий строк на мастере. Параметр `hot_standby_feedback` эффективно решает эту проблему ценой возможного "раздувания" (bloat) таблиц на мастере.
3.  **Логическая репликация** дает гибкость (репликация части таблиц), но требует наличия первичных ключей и не реплицирует DDL (изменения схемы) автоматически.
4.  **Failover:** Механизм `pg_promote` позволяет быстро восстановить доступность на запись, но требует последующей перенастройки старого мастера (например, через `pg_rewind`), чтобы вернуть его в кластер.