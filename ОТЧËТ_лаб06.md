# Отчет по лабораторной работе №06

# Блокировки и мониторинг

## Сведения о студенте

**Дата:** 2025-11-17
**Семестр:** 7
**Группа:** ПИЖ-б-о-22-1
**Дисциплина:** Администрирование баз данных
**Студент:** Матвеев Александр Иванович


## Цель работы
- Изучить систему блокировок в PostgreSQL и методы мониторинга активности сервера.
- Получить практические навыки анализа статистики, диагностики блокировок и взаимоблокировок,
использования инструментов мониторинга.

---

## Теоретическая часть

### Основные понятия

* **Блокировки (Locks)** — механизм, обеспечивающий согласованность данных при параллельном доступе. Разделяются на уровни: объекты (таблицы), строки и буферы в оперативной памяти.
* **Мониторинг** — использование системных представлений и функций для отслеживания активности сервера и статистики использования ресурсов. 
* **Взаимоблокировка (Deadlock)** — ситуация, при которой две или более транзакции бесконечно ожидают друг друга, так как каждая удерживает ресурс, необходимый другой. 

---

## Практическая часть

### Модуль 1: Мониторинг активности

#### Задача 1. Статистика таблиц

**Цель:** Проанализировать изменение статистики `pg_stat_all_tables` при манипуляции данными.

**Выполнение:**

Создание новой бд для выполнения лабораторной работы
```bash
sudo -u postgres createdb lab06_db
psql -d lab06_db
```

1.  Создание таблицы и генерация активности:

```sql
CREATE TABLE monitor_test (id INT);
INSERT INTO monitor_test SELECT generate_series(1, 1000);
DELETE FROM monitor_test;
```
Результат:
```text
CREATE TABLE
INSERT 0 1000
DELETE 1000
```

2.  Анализ статистики до очистки:

```sql
SELECT n_tup_ins, n_tup_del, n_live_tup, n_dead_tup 
FROM pg_stat_all_tables WHERE relname = 'monitor_test';
```
Результат:
```text
 n_tup_ins | n_tup_del | n_live_tup | n_dead_tup 
-----------+-----------+------------+------------
      1000 |      1000 |          0 |          0
(1 row)
```
При проверке статистики обнаружено, что `n_dead_tup` равно 0, несмотря на выполненное удаление всех строк. Это объясняется тем, что фоновый процесс `autovacuum` успел выполнить очистку таблицы до момента запроса статистики, освободив место, занимаемое мертвыми кортежами. Факт удаления подтверждается счетчиком `n_tup_del` = 1000.

3.  Выполнение очистки и повторная проверка:

```sql
VACUUM monitor_test;
SELECT n_tup_ins, n_tup_del, n_live_tup, n_dead_tup 
FROM pg_stat_all_tables WHERE relname = 'monitor_test';
```

**Результат:**

```text
 n_tup_ins | n_tup_del | n_live_tup | n_dead_tup 
-----------+-----------+------------+------------
      1000 |      1000 |          0 |          0
(1 row)
```

*Вывод:* Команда `VACUUM` в данном случае ничего не сделала, так как мёртвые строчки до этого были очищены при помощи `autovacuum`. 

#### Задача 2. Взаимоблокировка (Deadlock)

**Цель:** Создать и диагностировать взаимоблокировку двух транзакций.

**Выполнение:**

1.  Подготовка данных:

```sql
INSERT INTO monitor_test VALUES (1), (2);
```

2.  Воспроизведение (два терминала):
* **Сеанс 1:** `BEGIN; UPDATE monitor_test SET id=10 WHERE id=1;`
* **Сеанс 2:** `BEGIN; UPDATE monitor_test SET id=20 WHERE id=2;`
* **Сеанс 1:** `UPDATE monitor_test SET id=200 WHERE id=2;` (ждет)
* **Сеанс 2:** `UPDATE monitor_test SET id=100 WHERE id=1;` (вызывает deadlock)

Результат (в Сеансе 2):
```text
ERROR:  deadlock detected
DETAIL:  Process 1974 waits for ShareLock on transaction 858; blocked by process 1870.
Process 1870 waits for ShareLock on transaction 859; blocked by process 1974.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "monitor_test"
```

3.  Анализ журнала сообщений:
```bash
sudo tail -n 10 /var/log/postgresql/postgresql-16-main.log
```

*Вывод:* В лог записывается детальная информация о запросах участников конфликта, что позволяет выявить проблемную логику приложения. [cite: 22]

#### Задача 3. Расширение pg\_stat\_statements

**Цель:** Настроить мониторинг запросов через расширение.

**Выполнение:**

1.  Подключение расширения:

Открытие файла конфигурации:
```bash
sudo nano /etc/postgresql/16/main/postgresql.conf
```

Изменение параметра:
```bash
shared_preload_libraries = 'pg_stat_statements'
```

Перезагрузка сервера:
```bash
sudo systemctl restart postgresql
```

Создание расширения в базе данных:
```sql
CREATE EXTENSION pg_stat_statements;
```

2.  Выполнение тестовой нагрузки и анализ:

```sql
SELECT query, calls, total_exec_time, mean_exec_time 
FROM pg_stat_statements ORDER BY total_exec_time DESC LIMIT 3;
```

**Результат:**

```text
                             query                              | calls |   total_exec_time    |    mean_exec_time    
----------------------------------------------------------------+-------+----------------------+----------------------
 create extension pg_stat_statements                            |     1 |            45.551515 |            45.551515
 SELECT query, calls, total_exec_time, mean_exec_time          +|     1 |             0.091588 |             0.091588
 FROM pg_stat_statements ORDER BY total_exec_time DESC LIMIT $1 |       |                      | 
 SELECT n_tup_ins, n_tup_del, n_live_tup, n_dead_tup           +|     1 | 0.047481999999999996 | 0.047481999999999996
 FROM pg_stat_all_tables WHERE relname = $1                     |       |                      | 
(3 rows)
```

*Вывод:* Представление позволяет находить "тяжелые" запросы по суммарному времени выполнения.

-----


### Модуль 2: Блокировки объектов

#### Задача 1. Блокировки при чтении

**Цель:** Изучить блокировки на уровне изоляции `Read Committed`. 

**Выполнение:**

1.  Чтение строки в транзакции:

```sql
BEGIN;
SELECT * FROM monitor_test WHERE id = 1;
```

PID первого сеанса:
```sql
SELECT pg_backend_pid();
```

2.  Проверка блокировок в другом сеансе:

```sql
SELECT locktype, relation::regclass, mode, granted 
FROM pg_locks WHERE pid = 2066;
```

**Результат:**

```text
  locktype  |   relation   |      mode       | granted 
------------+--------------+-----------------+---------
 relation   | monitor_test | AccessShareLock | t
 virtualxid |              | ExclusiveLock   | t
```

*Вывод:* Команда `SELECT` захватывает `AccessShareLock` на таблицу. Это самая слабая блокировка, конфликтующая только с `AccessExclusiveLock` (например, `DROP TABLE` или `TRUNCATE`), что позволяет другим транзакциям читать и изменять данные параллельно.

#### Задача 2. Повышение уровня блокировок (Serializable)

**Цель:** Воспроизвести ошибку сериализации из-за предикатных блокировок. 

**Выполнение:**

Создание индекса (необходимо для работы предикатных блокировок по диапазону):
```sql
CREATE INDEX ON monitor_test(id);
INSERT INTO monitor_test VALUES (10), (20), (30);
```

Сеанс 1: Запускаем транзакцию с уровнем SERIALIZABLE и читаем диапазон.
```sql
BEGIN ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM monitor_test WHERE id > 15;
```

Сеанс 2: Вставляем данные, попадающие в диапазон, который читал Сеанс 1.
```sql
BEGIN ISOLATION LEVEL SERIALIZABLE;
INSERT INTO monitor_test VALUES (25);
COMMIT;
```
Вставка проходит успешно, так как физической блокировки строк нет.

Сеанс 1: Пытаемся выполнить любое изменение данных или просто COMMIT.
```sql
INSERT INTO monitor_test VALUES (40);
```

**Результат:**

```text
ERROR:  could not serialize access due to read/write dependencies among transactions
DETAIL:  Reason code: Canceled on identification as a pivot, during commit attempt.
HINT:  The transaction might succeed if retried.
```

*Вывод:* В режиме `SERIALIZABLE` PostgreSQL отслеживает предикатные блокировки (SIReadLock). Вставка строки, влияющей на результат выборки другой транзакции, приводит к ошибке сериализации для предотвращения фантомного чтения.

Конечно. [cite\_start]Вы абсолютно правы: в методических указаниях сказано предоставить «полную последовательность выполненных SQL-команд»[cite: 60]. В предыдущей версии некоторые шаги были описаны словами, а не кодом.

Ниже представлен исправленный и детализированный раздел отчета, начиная с **Задачи 3 Модуля 2** и до конца работы. Вставлены точные команды для воспроизведения каждой ситуации.

-----

### Модуль 2: Блокировки объектов (продолжение)

#### Задача 3. Логирование долгих ожиданий

**Цель:** Настроить запись в журнал сообщений о ожиданиях блокировок, превышающих 100 мс.

**Выполнение:**

1.  **Настройка параметров сервера:**
Выполняем команды в `psql` для изменения конфигурации без перезагрузки сервера (применяем `pg_reload_conf`).

```sql
-- Включаем логирование ожиданий
ALTER SYSTEM SET log_lock_waits = on;
-- Устанавливаем порог ожидания в 100 миллисекунд
ALTER SYSTEM SET deadlock_timeout = '100ms';
-- Применяем изменения
SELECT pg_reload_conf();
```

*Проверка применения настроек:*

```sql
SHOW log_lock_waits;
SHOW deadlock_timeout;
```

Результат:
```text
 log_lock_waits 
----------------
 on


 deadlock_timeout 
------------------
 100ms
(1 row)
```

2.  **Воспроизведение длительного ожидания:**

* **Сеанс 1 (Блокируем строку):**

```sql
BEGIN;
UPDATE monitor_test SET id = 100 WHERE id = 1;
```

* **Сеанс 2 (Пытаемся изменить ту же строку):**
```sql
BEGIN;
UPDATE monitor_test SET id = 200 WHERE id = 1;
```

* **Сеанс 1 (Завершаем):**

```sql
COMMIT;
```
Результат:
После этого Сеанс 2 "отвиснет" и выполнится.

3.  **Анализ журнала сообщений:**
В терминале Linux проверяем последние записи лога PostgreSQL:

```bash
sudo tail -n 20 /var/log/postgresql/postgresql-16-main.log
```

**Результат в логе:**
В логе появилась запись:
```text
2025-11-30 14:45:38.931 MSK [2084] student@lab06_db LOG:  process 2084 still waiting for ShareLock on transaction 885 after 100.363 ms
2025-11-30 14:45:38.931 MSK [2084] student@lab06_db DETAIL:  Process holding the lock: 2066. Wait queue: 2084.
```

**Вывод:**
Параметр `log_lock_waits` заставил сервер зафиксировать событие превышения времени ожидания (`deadlock_timeout`). Это позволяет администратору диагностировать проблемы производительности, даже если они не приводят к полным взаимоблокировкам (deadlocks).

-----

### Модуль 3: Блокировки строк

#### Задача 1. Конфликт обновлений

**Цель:** Смоделировать обновление одной строки тремя командами UPDATE в разных сеансах и изучить типы блокировок[cite: 40, 41].

**Выполнение:**

1.  **Подготовка (3 терминала):**
Во всех трех сеансах вводим, но **не нажимаем Enter** сразу:

* **Сеанс 1:** `BEGIN; UPDATE monitor_test SET id = id + 1 WHERE id = 1;` (Нажимаем Enter — выполнилось).
* **Сеанс 2:** `BEGIN; UPDATE monitor_test SET id = id + 1 WHERE id = 1;` (Нажимаем Enter — завис).
* **Сеанс 3:** `BEGIN; UPDATE monitor_test SET id = id + 1 WHERE id = 1;` (Нажимаем Enter — завис).

2.  **Анализ блокировок:**

```sql
SELECT pid, locktype, mode, granted, relation::regclass 
FROM pg_locks 
WHERE relation = 'monitor_test'::regclass OR locktype = 'transactionid';
```

**Результат и объяснение:**
```text
 pid  |   locktype    |       mode       | granted |   relation   
------+---------------+------------------+---------+--------------
 2530 | relation      | RowExclusiveLock | t       | monitor_test
 2514 | relation      | RowExclusiveLock | t       | monitor_test
 2494 | relation      | RowExclusiveLock | t       | monitor_test
 2514 | tuple         | ExclusiveLock    | t       | monitor_test
 2530 | transactionid | ExclusiveLock    | t       | 
 2514 | transactionid | ShareLock        | f       | 
 2514 | transactionid | ExclusiveLock    | t       | 
 2494 | transactionid | ExclusiveLock    | t       | 
 2530 | tuple         | ExclusiveLock    | f       | monitor_test
(9 rows)
```

* **Сеанс 1:** Удерживает `RowExclusiveLock` на таблице и `ExclusiveLock` на собственном `transactionid`. `granted = t`.
* **Сеанс 2:** Удерживает `RowExclusiveLock` на таблице, но висит в ожидании (`granted = f`) блокировки `ShareLock` на `transactionid` Сеанса 1. Это блокировка конкретной строки (row lock).
* **Сеанс 3:** Висит в ожидании блокировки типа `tuple`. Фактически он ждет, пока освободится кортеж, чтобы встать в очередь за Сеансом 2.

#### Задача 2. Взаимоблокировка трех транзакций

**Цель:** Воспроизвести кольцевой deadlock.

**Выполнение:**
* **Сеанс 1:**
```sql
BEGIN;
UPDATE monitor_test SET id = 11 WHERE id = 1;
```
* **Сеанс 2:**
```sql
BEGIN;
UPDATE monitor_test SET id = 22 WHERE id = 2;
```
* **Сеанс 3:**
```sql
BEGIN;
UPDATE monitor_test SET id = 33 WHERE id = 3;
```
* **Сеанс 1:** `UPDATE monitor_test SET id = 222 WHERE id = 2;` (Ждет Сеанс 2).
* **Сеанс 2:** `UPDATE monitor_test SET id = 333 WHERE id = 3;` (Ждет Сеанс 3).
* **Сеанс 3:** `UPDATE monitor_test SET id = 111 WHERE id = 1;` (Ждет Сеанс 1, в результате получается **DEADLOCK**).
```text
ERROR:  deadlock detected
DETAIL:  Process 2530 waits for ShareLock on transaction 897; blocked by process 2494.
Process 2494 waits for ShareLock on transaction 898; blocked by process 2514.
Process 2514 waits for ShareLock on transaction 899; blocked by process 2530.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "monitor_test"
```

**Результат:**
PostgreSQL обнаруживает цикл (1 ждет 2, 2 ждет 3, 3 ждет 1) и прерывает транзакцию Сеанса 3 с ошибкой `ERROR: deadlock detected`. В журнале сервера отображается полный граф ожиданий.

#### Задача 3. Взаимоблокировка UPDATE (две транзакции)

**Цель:** Воспроизвести deadlock двумя транзакциями на одной таблице.

**Выполнение:**

* **Сеанс 1:**
```sql
BEGIN;
UPDATE monitor_test SET id = id + 100 WHERE id = 1;
```
* **Сеанс 2:**
```sql
BEGIN;
UPDATE monitor_test SET id = id + 100 WHERE id = 2;
```
* **Сеанс 1:**
```sql
UPDATE monitor_test SET id = id + 100 WHERE id = 2; 
```
* **Сеанс 2:**
```sql
UPDATE monitor_test SET id = id + 100 WHERE id = 1; 
```
Результат:
```text
ERROR:  deadlock detected
DETAIL:  Process 2514 waits for ShareLock on transaction 902; blocked by process 2494.
Process 2494 waits for ShareLock on transaction 903; blocked by process 2514.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,8) in relation "monitor_test"
```

**Вывод:** Взаимоблокировка возможна, если транзакции обновляют одни и те же строки в **разном порядке**.

-----

### Модуль 4: Блокировки в оперативной памяти

#### Задача 1. Закрепление буферов (Pinning)

**Цель:** Убедиться, что курсор удерживает закрепление буфера (pinning) для быстрого чтения следующей строки.

**Выполнение:**

1.  **Сеанс 1 (Открываем курсор):**

```sql
BEGIN;
DECLARE c1 CURSOR FOR SELECT * FROM monitor_test;
FETCH 1 FROM c1; 
```

2.  **Сеанс 2 (Проверяем пины):**
```sql
CREATE EXTENSION IF NOT EXISTS pg_buffercache;

SELECT bufferid, relname, pinning_backends 
FROM pg_buffercache b
JOIN pg_class c ON b.relfilenode = c.relfilenode
WHERE c.relname = 'monitor_test' AND pinning_backends > 0;
```

**Результат:**
```text
 bufferid |   relname    | pinning_backends 
----------+--------------+------------------
      425 | monitor_test |                1
```
Запрос возвращает строку, где `pinning_backends = 1`. Это подтверждает, что открытый курсор удерживает буфер.

#### Задача 2. VACUUM и закрепление буферов

**Цель:** Проверить, ждет ли VACUUM освобождения пина.

**Выполнение:**
Не закрывая курсор в Сеансе 1, выполняем в Сеансе 2:

```sql
VACUUM monitor_test;
```

**Результат:**
Команда выполняется мгновенно и успешно завершается. `VACUUM` пропускает страницы, которые закреплены (pinned), чтобы не блокировать работу пользователей. Он очищает только то, что доступно.

#### Задача 3. VACUUM FREEZE и ожидание

**Цель:** Проверить поведение VACUUM FREEZE при наличии пина.

**Выполнение:**
Выполняем в Сеансе 2:

```sql
VACUUM FREEZE monitor_test;
```

**Результат:**
Команда **зависает**.
Проверяем причину ожидания в третьем терминале:

```sql
SELECT pid, wait_event_type, wait_event, query 
FROM pg_stat_activity 
WHERE query LIKE 'VACUUM%';
```

Результат:
```text
 pid  | wait_event_type | wait_event |            query            
------+-----------------+------------+-----------------------------
 2514 | BufferPin       | BufferPin  | VACUUM FREEZE monitor_test;
(1 row)
```

**Вывод:**
В столбце `wait_event` видим `BufferPin`. Операция `FREEZE` обязана обработать все страницы для заморозки идентификаторов транзакций, поэтому она **вынуждена ждать**, пока курсор в Сеансе 1 не будет закрыт (или не сдвинется на другую страницу).

-----

## Итоговые выводы

1.  **Мониторинг:** PostgreSQL предоставляет мощные средства (`pg_stat_activity`, `pg_locks`, `pg_stat_statements`) для диагностики производительности и проблем блокировок.
2.  **Уровни блокировок:** Важно различать блокировки тяжелые (Exclusive) и легкие (Share), а также понимать разницу между блокировками таблиц, строк и страниц памяти.
3.  **Deadlocks:** Взаимоблокировки — естественная часть работы при высокой конкуренции. Их необходимо минимизировать правильным порядком операций в приложении, а лог сервера помогает найти причину.
4.  **Buffer Pin:** Блокировки в оперативной памяти (пины) могут неочевидным образом влиять на административные задачи, такие как `VACUUM FREEZE`. 