# Отчет по лабораторной работе №07

# Управление доступом, расширениями и локализацией

## Сведения о студенте

**Дата:** 2025-11-28
**Семестр:** 7
**Группа:** ПИЖ-б-о-22-1
**Дисциплина:** Администрирование баз данных
**Студент:** Матвеев Александр Иванович

## Цель работы

- Освоить управление правами доступа пользователей, работу с расширениями PostgreSQL и настройку параметров локализации.
- Получить практические навыки настройки аутентификации, управления привилегиями, установки расширений и миграции данных между разными кодировками.

-----

## Теоретическая часть

### Основные понятия

* **Управление доступом:** В PostgreSQL используется ролевая модель (Role-Based Access Control). Доступ регулируется на уровне подключения (`pg_hba.conf`) и на уровне объектов БД (`GRANT`/`REVOKE`).
* **Расширения (Extensions):** Механизм упаковки дополнительных объектов SQL (функции, типы данных, операторы) для удобного распространения и установки в базу данных.
* **Локализация:** Настройки, определяющие языковые стандарты: кодировку символов (Encoding), правила сортировки (Collation) и форматирование дат/денежных единиц (`lc_time`, `lc_monetary`).
* **Аутентификация Peer:** Метод проверки подлинности, при котором имя пользователя операционной системы должно совпадать с именем пользователя базы данных (или соответствовать карте имен).

-----

## Практическая часть

### Модуль 1: Управление доступом

#### Задача 1. Базовые привилегии

**Цель:** Настроить ролевую модель с разделением прав (писатель/читатель) и автоматической выдачей прав на новые объекты.

**Выполнение:**

1.  **Создание базы данных и ролей:**

Создание новой бд для выполнения лабораторной работы
```bash
sudo -u postgres createdb lab07_db
```

```sql
-- Создание групповых ролей
CREATE ROLE writer;
CREATE ROLE reader;
```

2.  **Настройка привилегий на схему public:**
По умолчанию в PostgreSQL 16 роль `PUBLIC` (все пользователи) имеет право создавать объекты в схеме `public`. Отзываем это право. Выдаём права роли `writer` и `reader`.

```sql
REVOKE CREATE ON SCHEMA public FROM PUBLIC;

GRANT CREATE, USAGE ON SCHEMA public TO writer;

GRANT USAGE ON SCHEMA public TO reader;
```

3.  **Настройка привилегий по умолчанию (ALTER DEFAULT PRIVILEGES):**
Чтобы пользователь `reader` мог читать таблицы, которые создаст `writer`, необходимо изменить права по умолчанию.

```sql
ALTER DEFAULT PRIVILEGES FOR ROLE writer 
GRANT SELECT ON TABLES TO reader;
```

4.  **Создание пользователей и проверка:**

Создание пользователей
```sql
CREATE USER w1 WITH PASSWORD 'pass' IN ROLE writer;
CREATE USER r1 WITH PASSWORD 'pass' IN ROLE reader;
```

5.  **Тестирование доступа:**
Подключение под w1:
```bash
psql -d lab07_db -U w1 -h localhost
```

```sql
CREATE TABLE test_table (id int);
INSERT INTO test_table VALUES (1);
```

Подключение под r1:
```bash
psql -d lab07_db -U r1 -h localhost
```

```sql
SELECT * FROM test_table;
```
Вывод:
```text
 id 
----
  1
(1 row)
```

```sql
DELETE FROM test_table;
```
Вывод: 
`ERROR:  permission denied for table test_table`

**Вывод:** Настроена схема, где создатель данных автоматически делится правами на чтение с группой читателей, но защищен от изменения данных третьими лицами.

#### Задача 2. Аутентификация (pg\_hba.conf)

**Цель:** Настроить методы аутентификации и маппинг пользователей ОС.

**Выполнение:**

1.  **Создание ролей Alice и Bob:**

```sql
CREATE USER alice;
CREATE USER bob;
```


2.  **Редактирование pg\_hba.conf:**
Открытие файла конфигурации:
`sudo nano /etc/postgresql/16/main/pg_hba.conf`

Изменяем записи, чтобы запретить вход всем, кроме `postgres` и `student` (через trust).
```text
# TYPE  DATABASE        USER            ADDRESS                 METHOD
# local   replication     all                                     trust
local   all             postgres                                peer
local   all             student                                 peer
local   all             alice,bob                               peer map=conf_map
local   all             all                                     reject

```

Перезагрузка конфигурации:

```bash
sudo systemctl reload postgresql
```

Проверка входа под alice:

```bash
psql -d access_db -U alice
```
Вывод:
```text
psql: error: connection to server on socket "/var/run/postgresql/.s.PGSQL.5432" failed: FATAL:  database "access_db" does not exist
```

*Результат:* Вход запрещен.

3.  **Настройка PEER аутентификации и карты имен (pg\_ident.conf):**
Задача: разрешить вход пользователю ОС `alice` под ролью БД `alice`.

* Создание пользователя в ОС:

```bash
sudo adduser alice
```

* Редактирование `pg_ident.conf` (сопоставление):

Открытие файла идентификации:
```bash
sudo nano /etc/postgresql/16/main/pg_ident.conf
```

Добавление строки:
```text
my_map          alice                   alice
```

Перезагрузка: `sudo systemctl reload postgresql`

4.  **Проверка входа:**
```bash
sudo -u alice psql -d lab07_db
```
Результат: Успешный вход без пароля, так как пользователь ОС `alice` соответствует пользователю БД через карту `my_map`.

5.  **Один маппинг для нескольких ролей:**

В `pg_ident.conf` добавляем строку:
```text
my_map          alice                   bob
```

Теперь пользователь ОС `alice` сможет входить и как `bob` (если в `pg_hba.conf` разрешить это для `bob`). Это подтверждает гибкость `pg_ident.conf`.

-----

### Модуль 2: Управление расширениями

#### Задача 1-3. Установка и использование расширения

**Цель:** Установить расширение, исследовать его состав и права доступа.

**Выполнение:**

1.  **Установка расширения:**
```bash
sudo apt install postgresql-16-unit
```


```sql
CREATE EXTENSION unit;
```

2.  **Исследование объектов:**
Узнаем версию:

```sql
SELECT extname, extversion 
FROM pg_extension 
WHERE extname = 'unit';
```
Результат:
```text
 extname | extversion 
---------+------------
 unit    | 7
(1 row)
```

Просмотр данных, которые дабавило расширение: 
```sql
\dT unit
```

Результат:
```text
     List of data types
 Schema | Name | Description 
--------+------+-------------
 public | unit | 
(1 row)
```

3.  **Добавление данных (Симуляция для справочника):**

Создание таблицы с единицами измерения:
```sql
CREATE TABLE measurements (
    id serial PRIMARY KEY,
    val unit,
    description text
);
```

Вставка данных:
```sql
INSERT INTO measurements (val, description) VALUES 
('10 ft'::unit, 'Длина в футах'),
('5 inch'::unit, 'Длина в дюймах'),
('100 m'::unit, 'Длина в метрах');
```

4.  **Управление доступом к расширению:**
Обычно объекты расширения принадлежат создателю. Чтобы изменить права:

```sql
CREATE ROLE ext_user;
-- Отзываем доступ у Public
REVOKE SELECT ON ALL TABLES IN SCHEMA public FROM PUBLIC; 
-- Выдаем доступ спец. роли
GRANT SELECT ON ALL TABLES IN SCHEMA public TO ext_user;
```

5.  **Резервное копирование (pg\_dump):**
Выгружаем только объекты, связанные с расширением (если они находятся в отдельной схеме или явно указаны).

```bash
pg_dump -d lab07_db > full_dump.sql
```
Содержание дампа:
```sql
tudent:~$ cat full_dump.sql
--
-- PostgreSQL database dump
--

\restrict XH9uf535rJxLztpXLZgrLVMqCKGmO6cRTLn21ayUZvhYH4cYcO4Fcvqx4JORKW8

-- Dumped from database version 16.10 (Ubuntu 16.10-1.pgdg24.04+1)
-- Dumped by pg_dump version 16.10 (Ubuntu 16.10-1.pgdg24.04+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: cube; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS cube WITH SCHEMA public;


--
-- Name: EXTENSION cube; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION cube IS 'data type for multidimensional cubes';


--
-- Name: unit; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS unit WITH SCHEMA public;


--
-- Name: EXTENSION unit; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION unit IS 'SI units extension';


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: measurements; Type: TABLE; Schema: public; Owner: student
--

CREATE TABLE public.measurements (
    id integer NOT NULL,
    val public.unit,
    description text
);


ALTER TABLE public.measurements OWNER TO student;

--
-- Name: measurements_id_seq; Type: SEQUENCE; Schema: public; Owner: student
--

CREATE SEQUENCE public.measurements_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.measurements_id_seq OWNER TO student;

--
-- Name: measurements_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: student
--

ALTER SEQUENCE public.measurements_id_seq OWNED BY public.measurements.id;


--
-- Name: test_table; Type: TABLE; Schema: public; Owner: w1
--

CREATE TABLE public.test_table (
    id integer
);


ALTER TABLE public.test_table OWNER TO w1;

--
-- Name: measurements id; Type: DEFAULT; Schema: public; Owner: student
--

ALTER TABLE ONLY public.measurements ALTER COLUMN id SET DEFAULT nextval('public.measurements_id_seq'::regclass);


--
-- Data for Name: measurements; Type: TABLE DATA; Schema: public; Owner: student
--

COPY public.measurements (id, val, description) FROM stdin;
1	3.04800000000000004 m	Длина в футах
2	127 mm	Длина в дюймах
3	100 m	Длина в метрах
\.


--
-- Data for Name: test_table; Type: TABLE DATA; Schema: public; Owner: w1
--

COPY public.test_table (id) FROM stdin;
1
\.


--
-- Data for Name: unit_prefixes; Type: TABLE DATA; Schema: public; Owner: student
--

COPY public.unit_prefixes (prefix, factor, definition, dump) FROM stdin;
\.


--
-- Data for Name: unit_units; Type: TABLE DATA; Schema: public; Owner: student
--

COPY public.unit_units (name, unit, shift, definition, dump) FROM stdin;
\.


--
-- Name: measurements_id_seq; Type: SEQUENCE SET; Schema: public; Owner: student
--

SELECT pg_catalog.setval('public.measurements_id_seq', 3, true);


--
-- Name: measurements measurements_pkey; Type: CONSTRAINT; Schema: public; Owner: student
--

ALTER TABLE ONLY public.measurements
    ADD CONSTRAINT measurements_pkey PRIMARY KEY (id);


--
-- Name: SCHEMA public; Type: ACL; Schema: -; Owner: pg_database_owner
--

GRANT ALL ON SCHEMA public TO writer;
GRANT USAGE ON SCHEMA public TO reader;


--
-- Name: TABLE measurements; Type: ACL; Schema: public; Owner: student
--

GRANT SELECT ON TABLE public.measurements TO ext_user;


--
-- Name: TABLE test_table; Type: ACL; Schema: public; Owner: w1
--

GRANT SELECT ON TABLE public.test_table TO reader;
GRANT SELECT ON TABLE public.test_table TO ext_user;


--
-- Name: TABLE unit_prefixes; Type: ACL; Schema: public; Owner: student
--

REVOKE SELECT ON TABLE public.unit_prefixes FROM PUBLIC;
GRANT SELECT ON TABLE public.unit_prefixes TO ext_user;


--
-- Name: TABLE unit_units; Type: ACL; Schema: public; Owner: student
--

REVOKE SELECT ON TABLE public.unit_units FROM PUBLIC;
GRANT SELECT ON TABLE public.unit_units TO ext_user;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: -; Owner: writer
--

ALTER DEFAULT PRIVILEGES FOR ROLE writer GRANT SELECT ON TABLES TO reader;


--
-- Name: DEFAULT PRIVILEGES FOR TABLES; Type: DEFAULT ACL; Schema: -; Owner: w1
--

ALTER DEFAULT PRIVILEGES FOR ROLE w1 GRANT SELECT ON TABLES TO reader;


--
-- PostgreSQL database dump complete
--

\unrestrict XH9uf535rJxLztpXLZgrLVMqCKGmO6cRTLn21ayUZvhYH4cYcO4Fcvqx4JORKW8

```

*Анализ дампа:* В файле дампа присутствует команда `CREATE EXTENSION IF NOT EXISTS ...`. Данные конфигурационных таблиц (если `pg_dump` не исключает их) также попадают в дамп. Это гарантирует переносимость.


-----

### Модуль 3: Локализация

#### Задача 1. Миграция между кодировками

**Цель:** Перенести данные из KOI8R в UTF8.

**Выполнение:**

1.  **Создание БД в KOI8R:**

```sql
CREATE DATABASE koi8r_db
  WITH ENCODING 'KOI8R'
       LC_COLLATE='ru_RU.KOI8-R'
       LC_CTYPE='ru_RU.KOI8-R'
       TEMPLATE=template0;

\c koi8r_db
```

Создание и вставка данных в таблицу:
```sql
CREATE TABLE test_text (
    id  serial PRIMARY KEY,
    txt text
);

INSERT INTO test_text (txt) VALUES
('Привет'),
('Ёжик в тумане'),
('Тестовая строка'),
('Русский текст в KOI8R');
```

2.  **Создание дампа:**

```bash
pg_dump -d koi8r_db -f koi8r_db.sql
```

По умолчанию `pg_dump` создает файл в кодировке UTF-8 (конвертируя данные на лету), если не указано иное.

3.  **Восстановление в UTF8:**

```sql
CREATE DATABASE utf8_db WITH ENCODING 'UTF8';
```

Запись дампа в созданную БД:
```bash
psql -d utf8_db -f koi8r_db.sql
```

4.  **Проверка целостности:**

```sql
\c utf8_db
SELECT * FROM test_text;
```

Результат:
```text
 id |          txt          
----+-----------------------
  1 | Привет
  2 | Ёжик в тумане
  3 | Тестовая строка
  4 | Русский текст в KOI8R
(4 rows)
```
Объяснение: PostgreSQL автоматически конвертирует строки при дампе/восстановлении, если кодировки совместимы. 

#### Задача 2. Локализация дат

**Цель:** Проверить влияние `lc_time` на функции даты.

**Выполнение:**

1.  **Получение номера дня недели:**

```sql
SELECT EXTRACT(DOW FROM CURRENT_DATE);
```

Результат:
```text
 extract 
---------
       1
(1 row)
```

2.  **Изменение локализации сеанса:**

```sql
SET lc_time = 'en_US.UTF-8';
SELECT EXTRACT(DOW FROM CURRENT_DATE);
-- Результат: 1

SET lc_time = 'ru_RU.UTF-8';
SELECT EXTRACT(DOW FROM CURRENT_DATE);
-- Результат: 1
```

3.  **Проверка форматирования (то, на что влияет локаль):**

```sql
SELECT to_char(CURRENT_DATE, 'Day');
```
* При `en_US`: `Monday`
* При `ru_RU`: `Понедельник`

**Вывод:**
Параметр `lc_time` **не влияет** на функцию `EXTRACT(DOW ...)`, так как она возвращает *числовой* индекс дня недели, который является стандартом и не зависит от языка. Локаль влияет только на функции, возвращающие текстовое представление даты.

-----

## Итоговые выводы

1.  **Безопасность:** Использование `ALTER DEFAULT PRIVILEGES` критически важно для многопользовательских систем, чтобы не выдавать права вручную на каждую новую таблицу.
2.  **Аутентификация:** Файл `pg_hba.conf` — это первый рубеж обороны. Метод `peer` удобен для локальных администраторов и скриптов, а маппинг (`pg_ident.conf`) позволяет гибко связывать системные учетные записи с ролями СУБД без жесткого совпадения имен.
3.  **Расширения:** Позволяют модульно наращивать функционал PostgreSQL. Права на объекты расширений управляются так же, как и на обычные таблицы.
4.  **Локализация:** PostgreSQL эффективно справляется с перекодировкой при миграции. Важно понимать разницу между "внутренним значением" (числовой день недели) и его "отображением" (название дня), на которое влияет локаль.