# Отчет по лабораторной работе №05

# Надежность: Журнал предзаписи (WAL)


## Сведения о студенте
**Дата:** 2025-11-15
**Семестр:** 7
**Группа:** ПИЖ-б-о-22-1
**Дисциплина:** Администрирование баз данных
**Студент:** Матвеев Александр Иванович


## Цель работы
- Изучить работу буферного кеша и механизма журналирования предзаписи (WAL) в PostgreSQL.
- Получить практические навыки управления контрольными точками, анализа журнальных записей, настройки параметров WAL и исследования процессов восстановления после сбоев.

---

## Теоретическая часть

### Основные понятия

* **Буферный кеш (Buffer Cache)** — область в оперативной памяти (Shared Memory), используемая для кэширования страниц данных, считанных с диска. Измененные данные сначала попадают сюда («грязные буферы»), а затем сбрасываются на диск.
* **Контрольная точка (Checkpoint)** — процесс принудительной записи всех «грязных» буферов из памяти на диск. Это событие сокращает время восстановления, так как гарантирует, что все транзакции до этого момента надежно сохранены.
* **Журнал предзаписи (WAL)** — циклический журнал, в который последовательно записываются все изменения данных *перед* тем, как они попадут в основные файлы данных (heap).. Это гарантирует атомарность и долговечность данных (ACID).
* **Восстановление (Recovery)** — процесс чтения WAL-записей после сбоя (или при репликации) и применение изменений к файлам данных для приведения системы в согласованное состояние.

---

## Практическая часть

### Модуль 1: Процессы и режимы остановки

#### Задача 1. Поиск процессов

**Цель:** Идентифицировать фоновые процессы PostgreSQL, отвечающие за надежность.

**Выполнение:**
Выполнил поиск процессов через терминал ОС:

```bash
ps aux | grep postgres
```

**Результат:**
Были найдены ключевые процессы:
  * `checkpointer` — выполняет контрольные точки.
  * `background writer` — фоновая запись грязных страниц.
  * `walwriter` — запись данных из WAL-буфера в файлы журнала.

#### Задача 2. Остановка Fast

**Цель:** Проверить поведение системы при штатной (быстрой) остановке.

**Выполнение:**

1.  Остановка сервера в режиме `fast` (прерывает транзакции, делает чекпоинт):
```bash
sudo pg_ctlcluster 16 main stop
```

2.  Запуск сервера:
```bash
sudo pg_ctlcluster 16 main start
```

3.  Просмотр журнала сообщений:
```bash
sudo tail -n 20 /var/log/postgresql/postgresql-16-main.log
```

**Результат:**

```text
2025-11-24 12:32:53.901 MSK [1070] LOG:  shutting down
2025-11-24 12:32:53.901 MSK [1070] LOG:  checkpoint starting: shutdown immediate
2025-11-24 12:32:53.904 MSK [1070] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.001 s, total=0.004 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=36179 kB; lsn=0/B5E6B60, redo lsn=0/B5E6B60
2025-11-24 12:32:53.909 MSK [1052] LOG:  database system is shut down
2025-11-24 12:38:30.569 MSK [2456] LOG:  starting PostgreSQL 16.10 (Ubuntu 16.10-1.pgdg24.04+1) on aarch64-unknown-linux-gnu, compiled by gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, 64-bit
2025-11-24 12:38:30.569 MSK [2456] LOG:  listening on IPv4 address "127.0.0.1", port 5432
2025-11-24 12:38:30.569 MSK [2456] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
2025-11-24 12:38:30.578 MSK [2459] LOG:  database system was shut down at 2025-11-24 12:32:53 MSK
2025-11-24 12:38:30.586 MSK [2456] LOG:  database system is ready to accept connections

```

**Вывод:** При режиме `fast` сервер принудительно выполняет **контрольную точку** (`checkpoint: shut down`) перед выключением, сохраняя все данные на диск.

#### Задача 3. Остановка Immediate

**Цель:** Проверить поведение системы при аварийной остановке и автоматическое восстановление.

**Выполнение:**

1.  Остановка сервера в режиме `immediate` (имитация сбоя питания):
    ```bash
    sudo pg_ctlcluster 16 main stop -m immediate
    ```
2.  Запуск сервера:
    ```bash
    sudo pg_ctlcluster 16 main start
    ```
3.  Просмотр журнала сообщений:
    ```bash
    sudo grep "recovery" /var/log/postgresql/postgresql-16-main.log | tail
    ```

**Результат (из лога):**

```text
2025-11-24 11:08:02.512 MSK [1072] LOG:  database system was not properly shut down; automatic recovery in progress
2025-11-24 11:08:02.517 MSK [1070] LOG:  checkpoint starting: end-of-recovery immediate wait
```

**Вывод:** Режим `immediate` не выполняет контрольную точку. При запуске PostgreSQL обнаружил некорректное завершение и запустил процесс восстановления (`automatic recovery`), проиграв записи WAL.

-----

### Модуль 2: Буферный кеш и контрольные точки

#### Задача 1. Анализ размера

**Цель:** Сравнить физический размер таблицы и её место в буферном кеше.

**Выполнение:**

1.  Создание таблицы и наполнение данными (100 000 строк):
```sql
CREATE TABLE wal_test (id INT, data TEXT);
INSERT INTO wal_test SELECT generate_series(1, 100000), 'test_data';
```

2.  Установка расширения `pg_buffercache`:
```sql
CREATE EXTENSION IF NOT EXISTS pg_buffercache;
```

3.  Определение размера на диске (в страницах):
```sql
SELECT pg_relation_size('wal_test') / current_setting('block_size')::int AS disk_pages;
```

Результат:
```text
 disk_pages 
------------
        541
(1 row)
```

4.  Определение количества страниц в кеше:
```sql
SELECT count(*) FROM pg_buffercache 
WHERE relfilenode = pg_relation_filenode('wal_test'::regclass);
```
Результат: 
```text
 count 
-------
   545
(1 row)
```

**Вывод:** Вся таблица полностью (и служебные данные) загружены в буферный кеш.

#### Задача 2. Грязные буферы и контрольная точка

**Цель:** Отследить сброс грязных страниц на диск.

**Выполнение:**

1.  Изменение данных (создание "грязных" буферов):
```sql
UPDATE wal_test SET data = 'dirty' WHERE id < 50000;
```

2.  Проверка количества грязных буферов:
```sql
SELECT count(*) FROM pg_buffercache 
WHERE relfilenode = pg_relation_filenode('wal_test'::regclass) AND isdirty = true;
```

Результат: 
```
 count 
-------
   546
(1 row)
```

3.  Выполнение контрольной точки:
```sql
CHECKPOINT;
```

4.  Повторная проверка грязных буферов (тот же запрос):
Результат:
```text
 count 
-------
     0
(1 row)
```

**Вывод:** Команда `CHECKPOINT` записала измененные блоки на диск и сняла флаг `isdirty`.

#### Задача 3. Предварительное чтение (pg\_prewarm)

**Цель:** Проверить сохранение кеша после перезагрузки.

**Выполнение:**

1.  Подключение расширения и загрузка таблицы в кеш:
```sql
CREATE EXTENSION IF NOT EXISTS pg_prewarm;
SELECT pg_prewarm('wal_test');
```

Результат:
```text
  pg_prewarm 
------------
    811
(1 row)

```

2.  Перезагрузка сервера (через терминал):
```bash
sudo pg_ctlcluster 16 main restart
```

3.  Проверка наличия в кеше (SQL):
```sql
SELECT count(*) FROM pg_buffercache 
WHERE relfilenode = pg_relation_filenode('wal_test'::regclass);
```
Результат:
```text
 count 
-------
     0
(1 row)
```

**Вывод:** При перезапуске оперативная память очищается. Функция `pg_prewarm` работает только в моменте.

-----

### Модуль 3: Журнал предзаписи (WAL)

#### Задача 1. Размер WAL-записей

**Цель:** Измерить объем WAL, генерируемый транзакциями.

**Выполнение:**

1.  Фиксация текущей позиции LSN:
```sql
SELECT pg_current_wal_lsn() AS start_lsn; 
```

Результат: 
```text
 start_lsn 
-----------
 0/CA80CD8
(1 row)
```

2.  Выполнение транзакции:
```sql
INSERT INTO wal_test SELECT generate_series(1, 1000), 'wal_check';
```

3.  Вычисление объема WAL:
```sql
SELECT pg_current_wal_lsn() - '0/CA80CD8'::pg_lsn AS wal_bytes;
```

**Результат:** 
```text
 wal_bytes 
-----------
     80584
(1 row)
```

#### Задача 2. Анализ WAL

**Объяснение:** Размер WAL больше, чем "чистый" размер данных, так как записи включают метаданные, заголовки блоков и, возможно, полные образы страниц (Full Page Writes) при первом изменении страницы после чекпоинта.

#### Задача 3. Восстановление после сбоя

**Цель:** Убедиться в атомарности транзакций при "убийстве" процесса.

**Выполнение:**

1.  Вставка и фиксация данных:
```sql
INSERT INTO wal_test VALUES (999, 'committed_row');
COMMIT;
```

2.  Начало новой транзакции (без коммита) и определение PID процесса:
```sql
BEGIN;
UPDATE wal_test SET data = 'crash_test';
SELECT pg_backend_pid(); 
```

Результат: 
```text
 pg_backend_pid 
----------------
           2645
(1 row)
```


3.  Имитация сбоя (в другом терминале убиваем процесс):
```bash
sudo kill -9 2645
```

Результат в psql сессии: 
```text
server closed the connection unexpectedly
This probably means the server terminated abnormally
before or while processing the request.
The connection to the server was lost. Attempting reset: Succeeded.
```

4.  Подключение заново и проверка данных:
```sql
SELECT * FROM wal_test WHERE id = 999;
SELECT count(*) FROM wal_test WHERE data = 'crash_test'; 
```

Результат: 
```text
 id  |     data      
-----+---------------
 999 | wal_check
 999 | committed_row
 999 | dirty
(3 rows)

 count 
-------
     0
(1 row)

```

5.  Поиск записи о восстановлении в логах:
```bash
grep "database system is ready" /var/log/postgresql/postgresql-16-main.log
``` 

Результат: 
```text
2025-11-24 13:04:36.137 MSK [2626] LOG:  database system is ready to accept connections
```

**Вывод:** Зафиксированная транзакция сохранилась. Незавершенная транзакция откатилась. PostgreSQL автоматически восстановил целостность.

-----

### Модуль 4: Настройка WAL

#### Задача 1. Влияние full\_page\_writes

**Цель:** Оценить влияние параметра `full_page_writes` (запись полных страниц) на объем генерируемого журнала предзаписи.

**Выполнение:**

**Шаг 1. Тест с включенным параметром (по умолчанию)**
Параметр защищает от частичной записи страниц при сбое питания, записывая образ страницы целиком при первом изменении после контрольной точки.

1.  Включаем параметр и применяем настройки:
```sql
ALTER SYSTEM SET full_page_writes = on;
SELECT pg_reload_conf();
```

2.  Выполняем контрольную точку:
```sql
CHECKPOINT;
```

3.  Запоминаем текущую позицию WAL:
```sql
SELECT pg_current_wal_lsn() AS start_lsn_on \gset
```

4.  Выполняем массовое обновление данных:
```sql
UPDATE wal_test SET data = 'fpw_on_data';
```

5.  Замеряем объем сгенерированного WAL:
```sql
SELECT pg_size_pretty(pg_current_wal_lsn() - :'start_lsn_on'::pg_lsn) AS wal_size_on;
```
Результат:
```text
 wal_size_on 
-------------
 19 MB
(1 row)
```

**Шаг 2. Тест с выключенным параметром**
Отключаем защиту. Теперь в WAL пишутся только векторы изменений.

1.  Отключаем параметр:
```sql
ALTER SYSTEM SET full_page_writes = off;
SELECT pg_reload_conf();
```

2.  Снова выполняем контрольную точку:
```sql
CHECKPOINT;
```

3.  Запоминаем LSN:
```sql
SELECT pg_current_wal_lsn() AS start_lsn_off \gset
```

4.  Выполняем обновление данных:
```sql
UPDATE wal_test SET data = 'fpw_off_data';
```

5.  Замеряем объем:
```sql
SELECT pg_size_pretty(pg_current_wal_lsn() - :'start_lsn_off'::pg_lsn) AS wal_size_off;
```

Результат: 
```text
 wal_size_off 
--------------
 15 MB
(1 row)
```

**Вывод:** Отключение параметра снизило объем WAL с 19 МБ до 15 МБ. Разница составила 4 МБ, что практически точно совпадает с полным физическим размером таблицы.


#### Задача 2. Эффективность сжатия WAL

**Цель:** Оценить, насколько эффективно алгоритм сжатия (LZ4 или PGLZ) уменьшает размер записей полных страниц.

**Выполнение:**

Для корректного теста **включаем обратно** `full_page_writes`, так как сжатие работает именно для полных образов страниц.

1.  Возвращаем `full_page_writes` и включаем сжатие:
```sql
ALTER SYSTEM SET full_page_writes = on;
ALTER SYSTEM SET wal_compression = on;
SELECT pg_reload_conf();
```

2.  Выполняем контрольную точку:
```sql
CHECKPOINT;
```

3.  Запоминаем LSN:
```sql
SELECT pg_current_wal_lsn() AS start_lsn_comp \gset
```

4.  Генерируем нагрузку (то же обновление):
```sql
UPDATE wal_test SET data = 'compression_test';
```

5.  Замеряем объем:
```sql
SELECT pg_size_pretty(pg_current_wal_lsn() - :'start_lsn_comp'::pg_lsn) AS wal_size_compressed;
```

**Результат:** 
```text
 wal_size_compressed 
---------------------
 16 MB
(1 row)
```

**Вывод:** Включение `wal_compression` снизило общий объем WAL на 3 МБ. Учитывая выводы из Задачи 1, где мы выяснили, что объем полных образов страниц (FPW) составляет около 4 МБ, можно сделать вывод, что алгоритм сжатия сжал эти 4 МБ данных примерно до 1 МБ (коэффициент сжатия 4:1). Остальные 15 МБ — это логические записи изменений данных (заголовки и данные строк), на которые `wal_compression` не влияет. Таким образом, сжатие эффективно нивелирует накладные расходы от включения `full_page_writes`.

## Итоговые выводы

1.  **Надежность:** Лабораторная работа продемонстрировала, что PostgreSQL устойчив к сбоям. Механизм WAL гарантирует восстановление зафиксированных данных даже при `kill -9`.
2.  **Буферизация:** Данные активно кешируются. Запись на диск происходит асинхронно или через `CHECKPOINT`.
3.  **Восстановление:** Разные режимы остановки (`fast` vs `immediate`) влияют на время запуска: `immediate` требует проигрывания журнала WAL.
4.  **Настройка:** Параметры `full_page_writes` и `wal_compression` позволяют балансировать между надежностью, объемом дискового ввода-вывода и нагрузкой на процессор.