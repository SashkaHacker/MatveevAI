# Отчет по лабораторной работе №03

# Модель многопользовательского доступа: MVCC


## Сведения о студенте
**Дата:** 2025-11-05
**Семестр:** 7
**Группа:** ПИЖ-б-о-22-1
**Дисциплина:** Администрирование баз данных
**Студент:** Матвеев Александр Иванович


## Цель работы
Изучить принципы многоверсионного управления конкурентным доступом (MVCC) в PostgreSQL.
Получить практические навыки работы с уровнями изоляции транзакций, наблюдения версий строк и снимков данных, исследования внутренних структур с помощью системных представлений и расширения `pageinspect`, а также практики с экспортом/импортом снимков. 

## Теоретическая часть
### Изученные концепции
* **MVCC (Multiversion Concurrency Control)** — механизм, при котором изменения не перезаписывают строки «на месте», а создают новые версии. Разные транзакции могут видеть разные версии данных, минимизируя блокировки.
* **Системные столбцы:**
  * `xmin` — транзакция, создавшая версию строки.
  * `xmax` — транзакция, логически «удалившая» (или занявшая под UPDATE) данную версию.
  * `ctid` — физический адрес версии строки (страница, слот).
* **Снимок данных (snapshot)** — набор правил/идентификаторов, определяющий, какие версии строк видимы транзакции.
* **Уровни изоляции:**
  * `READ COMMITTED` — каждая команда видит только зафиксированные на её начало изменения. Возможны неповторяемые и фантомные чтения.
  * `REPEATABLE READ` — снимок фиксируется на начало транзакции. Нет неповторяемого чтения; возможны фантомы.
  * `SERIALIZABLE` — моделирует последовательное выполнение транзакций, предотвращая типичные аномалии.
* **pageinspect** — расширение для низкоуровневого анализа страниц таблиц/индексов.

## Практическая часть

### Модуль 1: Уровни изоляции и аномалии

#### Задача 1: Read Committed vs удаление
**Цель:** показать, что при `READ COMMITTED` повторный `SELECT` видит изменения, зафиксированные другой транзакцией.

**Выполненные действия:**
Создание новой бд для выполнения лабораторной работы
```bash
sudo -u postgresql createdb lab03_db
psql -d lab03_db
```

Создание тестовой таблицы и добавление записи:
```sql
CREATE TABLE iso_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO iso_test VALUES (1, 'row-1');
```

##### Сеанс 1
Явно начинаем транзакцию с уровнем READ COMMITTED
```sql
BEGIN ISOLATION LEVEL READ COMMITTED;
```
Проверяем, что строка видна
```sql
SELECT * FROM iso_test;
```
Результат:
```text
 id | data  
----+-------
  1 | row-1
(1 row)
```

**Описание:** BEGIN фиксирует границы транзакции; в READ COMMITTED каждый SELECT берёт свежий снимок на момент выполнения.

##### Сеанс 2
Удаляем строку и фиксируем изменение
```sql
DELETE FROM iso_test WHERE id = 1;
COMMIT;
```
Результат:
```sql
DELETE 1
WARNING:  there is no transaction in progress
COMMIT
```

##### Сеанс 1 (продолжение)
Повторяем чтение в той же транзакции
```sql
SELECT * FROM iso_test;
COMMIT;
```
Результат:
```text 
 id | data 
----+------
(0 rows)
```

**Выводы и объяснения:**
В режиме `READ COMMITTED` каждая команда использует новый снимок; повторный `SELECT` видит зафиксированное удаление.

#### Задача 2: Repeatable Read vs удаление
**Цель:** показать, что при `REPEATABLE READ` транзакция продолжает видеть старое состояние, несмотря на коммиты других транзакций.

**Выполненные действия:**
##### Сеанс 1
Повторите предыдущий эксперимент, но в сеансе 1 начните транзакцию с BEGIN ISOLATION LEVEL REPEATABLE READ;.
```sql
BEGIN ISOLATION LEVEL REPEATABLE READ;

SELECT * FROM iso_test;
```
Результат: 
```text
 id | data  
----+-------
  1 | row-1
(1 row)
```

##### Сеанс 2
```sql
DELETE FROM iso_test WHERE id = 1;
COMMIT;
```
Результат:
```sql
DELETE 1
WARNING:  there is no transaction in progress
COMMIT
```

##### Сеанс 1 (продолжение)
```sql
SELECT * FROM iso_test;
COMMIT;
```
Результат: 
```text
 id | data  
----+-------
  1 | row-1
(1 row)
```

**Результаты:**
`REPEATABLE READ` снимок фиксируется на начало транзакции; последующие коммиты других транзакций не меняют видимость данных.

**Выводы и объяснения:**
Разница с `READ COMMITTED` в том, что `REPEATABLE READ`«замораживает» картину данных для всей транзакции.

#### Задача 3: Создание таблицы в транзакции
**Цель:** показать, что DDL-операции видимы другим сеансам только после `COMMIT` и откатываются при `ROLLBACK`.

**Выполненные действия:**
##### Сеанс 1
Начало транзакции, создание новой таблицы и вставка в неё новой строки, но без фиксации
```sql
BEGIN;
CREATE TABLE new_table (
    id INT PRIMARY KEY
);
INSERT INTO new_table VALUES (1);
```

##### Сеанс 2
Выполняем обращение к созданной, но не зафиксированной таблице.
```sql
SELECT * FROM new_table;
```
Результаты: 
```sql
ERROR:  relation "new_table" does not exist
LINE 1: SELECT * FROM new_table;
```

##### Сеанс 1
Фиксируем транзакцию
```sql
COMMIT;
```

##### Сеанс 2 (повтор)
Повторяем запрос после коммита
```sql
SELECT * FROM new_table;
```
Результат:
```text
 id 
----
  1
(1 row)
```

##### Сеанс 1
Теперь повторим с откатом:
```sql
BEGIN;
CREATE TABLE new_table_2 (id INT);
ROLLBACK;
```

##### Сеанс 2
Обращаемся к таблице:
```sql
SELECT * FROM new_table_2;
```
Результат: 
```sql
ERROR:  relation "new_table_2" does not exist
LINE 1: SELECT * FROM new_table_2;
```

**Вывод:**
DDL в PostgreSQL транзакционен: до COMMIT объекты не видны другим сеансам, при ROLLBACK полностью откатываются.

---

#### Задача 4. Блокировка DDL

**Цель:** показать, что активная транзакция, читающая таблицу, мешает её удалению.

##### Сеанс 1
Начинаем транзакцию и выполняем запрос к таблице:
```sql
BEGIN;
SELECT * FROM iso_test;
```

**Описание:** SELECT берёт `ACCESS SHARE` lock на `iso_test`, удерживаемый до COMMIT/ROLLBACK.

##### Сеанс 2
```sql
DROP TABLE iso_test;
```
Результат: команда блокируется (не выполняется) до тех пор, пока транзакция в 1 сеансе не будет завершена.

##### Сеанс 1
```sql
COMMIT;
```

##### Сеанс 2
Результат: после освобождения блокировки DROP TABLE завершается успешно


**Вывод:** DDL-операция `DROP TABLE` требует `ACCESS EXCLUSIVE` lock, конфликтующий с активным `ACCESS SHARE` lock в другой транзакции.

---

### Модуль 2: Фантомное чтение и снимки

#### Задача 1: Фантомное чтение (Read Committed)
**Цель:** показать, что новые строки, вставленные в другой транзакции, становятся видимыми между двумя `SELECT` в `READ COMMITTED`.

**Выполненные действия:**
Создание пустой таблицы
```sql
CREATE TABLE phantom_test (id INT);
```

##### Сеанс 1
```sql
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT * FROM phantom_test;
```
Результат: 
```text
 id 
----
(0 rows)
```

##### Сеанс 2
```sql
INSERT INTO phantom_test VALUES (1), (2);
COMMIT;
```
Результат: 
```text
 id 
----
  1
  2
(2 rows)
```

**Вывод:** В READ COMMITTED диапазонный запрос может возвращать разные наборы строк при повторном выполнении.

---

#### Задача 2: Невидимость удалений (Repeatable Read)
**Цель:** показать, что при `REPEATABLE READ` удалённые строки остаются видимыми в рамках транзакции.

**Выполненные действия:**
Очистка таблицы и запись новых значений
```sql
TRUNCATE phantom_test;
INSERT INTO phantom_test VALUES (1), (2), (3);
```

##### Сеанс 1
Начало транзакции с уровнем Repeatable Read:
```sql
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM phantom_test;
```
Результат:
```text
 id 
----
  1
  2
  3
(3 rows)
```

##### Сеанс 2
Удаление всех строк из таблицы и фиксация изменений:
```sql
DELETE FROM phantom_test;
COMMIT;
```

##### Сеанс 1 (продолжение)
Выполнение запроса к таблице:
```sql
SELECT * FROM phantom_test;
```
Результат:
```text
 id 
----
  1
  2
  3
(3 rows)
```

Выполнение допольнительного запроса:
```sql
SELECT * FROM pg_database;
```

Повторное выполнение запроса к таблице:
```sql
SELECT * FROM phantom_test;
-- Всё ещё те же 3 строки
COMMIT;
```
Результат:
```text
 id 
----
  1
  2
  3
(3 rows)
```

**Вывод:** В `REPEATABLE READ` результат повторных запросов по тем же условиям стабилен для транзакции, даже если другие транзакции меняют данные. Это подтверждает работу фиксированного снимка.

---
#### Задача 3: Транзакционность DDL
**Цель:** убедиться, что `DROP TABLE` можно откатить.

**Выполненные действия:**
```sql
CREATE TABLE ddl_tx_test (id INT);
INSERT INTO ddl_tx_test VALUES (1);
```

```sql
BEGIN;
DROP TABLE ddl_tx_test;
ROLLBACK;
```

```sql
SELECT * FROM ddl_tx_test;
```

**Результаты:**
После отката изменений таблица и запись в ней восстановились:
```text
 id 
----
  1
(1 row)
```

**Вывод:** DROP TABLE — транзакционный: при откате объект восстанавливается (по сути, удаление не фиксируется).

## Итоговые выводы

1. MVCC в PostgreSQL обеспечивает параллелизм за счёт хранения нескольких версий строк и выбора видимости по снимкам, а не за счёт жёстких блокировок на чтение.
2. Уровни изоляции:

   * READ COMMITTED даёт актуальные данные на момент каждой команды и допускает неповторяемость и фантомы.
   * REPEATABLE READ фиксирует снимок для транзакции, устраняя неповторяемое чтение.
3. DDL и многие операции над данными транзакционны: создаваемые/удаляемые объекты видимы другим только после COMMIT; ошибки можно откатывать.
4. Расширение `pageinspect` позволяет наблюдать реальные версии строк, подтверждая теоретическую модель MVCC.
5. `ON_ERROR_ROLLBACK` в psql демонстрирует использование внутренних SAVEPOINT, что удобно при работе с длинными транзакциями.
6. Экспорт/импорт снимков и поведение функций STABLE/VOLATILE показывают гибкость управления видимостью данных и важность понимания того, какой снимок когда используется.

Этот отчёт можно прямо сдавать, подставив фактические выводы команд из твоей среды PostgreSQL (где сейчас стоят ожидаемые результаты).
